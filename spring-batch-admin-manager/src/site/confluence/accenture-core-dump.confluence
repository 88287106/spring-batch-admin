h1. Market and Project Core Dump

Meeting on 2009/06/24 with Lucas Ward (Accenture, Spring Batch lead).  Also present: Dave Syer, Shaun Connolly, Mark Fisher.

h2. Principle Pain Points

The questions posed were "what pain points are there in batch projects?" and "what did you have to do to implement a successful project that wasn't provided by Spring Batch?".  Some of the answers reveal commercial opportunities in the runtime, scalability or operations space (as opposed to pure programming model). 

h3. Batch Console

Many projects, including big ticket ones, specify upfront that they want a web UI for visualizing the Batch job executions and their history.  It is almost always cut from the project plan later for want of development resources, but if a licensed product was available it would have been included, as long as the price was lower than the estimated development.  The envisioned UI would simply reflect the contents of the meta-data tables - so the jobs themselves would be running in different processes, often triggered by enterprise schedulers as Java mains. 

We have quite a bit of code available here already, so could be a quick win with a shrink-wrapped offering here, as a plain WAR (deployable on any platform).

h3. Configuration Admin

Being able to tweak the configuration of jobs, especially those already executing is a very popular request (usually, presumably, denied).  We can assume that the set of tweakable properties is limited, and that for executing jobs even narrower (commit interval is the one that is always mentioned).  Persistent storage of the external configuration is of course necessary, and users would not want to have to restart a console or admin application to have the changes applied: this presents some nice technical challenges. 

h3. Scheduler

Most large projects use "enterprise" scheduling tools, like Autosys, Control-M, Tivoli.  Cron is also used for smaller projects.  The enterprise tools will probably never go away, and clients have teams of ops people who know and like the control they get over dependencies and notifications.  Some of that could be replaced by a SpringSource lightweight solution, with a combination of native Spring features and Hyperic for notification and monitoring.  Smaller shops, and new projects where there is no incumbent scheduler would find that more attractive.

Such third party schedulers always work at the OS process level.  They can start processes and report on their success and execution times, but looking inside a process and (worse still for clients) stopping them gracefully requires more detailed application level knowledge.  Since Spring Batch sits in between the application code and the OS process, we are in a good position to add value here through instrumentation and additional "container" features.

h4. Missed triggers

Enterprise schedulers generally can "catch up" if the system they were managing missed a few triggers (while it was down for maintenance for instance).  This is pretty crude, and maybe could be improved with deeper knowledge of the job, recognizing various stopped and restart scenarios.  Also, in shops where there is no incumbent scheduler this would be an important feature on top of more lightweight solutions (Cron or Spring scheduling). 

h4. FTP Triggers

A recurring theme is triggering job execution from a file copy via filesystem or FTP.  To be as robust as possible, best practice now is to trigger a webservice or JMS message from the file drop, and use that signal to start a job.  The infrastructure for this is fiddly to set up and hard to test.  Spring Integration and Spring batch together are a good story for the application developer. Maybe also for the runtime?  

h3. Data Mining in Meta Data

In addition to just providing a window on the meta-data (the [#BatchConsole]) there is also a wealth of information in the Spring batch meta data that can be mined for reporting and quality assurance purposes.  Capacity planning is a huge endeavour, and we can provide historical and statistical analysis to support that.  Also Service Level Agreements (SLA) are very common, especially for partners like Accenture, and they need data to be able to specify and prove that the targets are being met.  This is clearly a commercial opportunity, if the  links to present the data in the right way, or integrate with existing systems can be found.  

h3. Provisioning and Deployment

A major pain point in large projects is provisioning deployment of application artifacts.

h4. Upgrades

In particular, the upgrade scenario is painful for all.  How do you stop existing executions gracefully (generally you can't if using Autosys and friends)?  How do you ensure  that existing job executions continue to execute after the upgrade?

h4. JVM Tuning

Many jobs in large projects are so individual, and so large, that JVM tuning is necessary to optimise the execution.  This often leads them to be run in separate OS processes.

There is however a huge tension between the need to tune each job process and the need to find a standard deployment and provisioning platform.  So often (hugely expensive) JEE application servers are used as shallow containers for jobs that need very different tuning to their online application counterparts.  This is far from ideal, but is tolerated because the ops teams have management and monitoring infrastrusture in place that they know and trust to serve these ends.

h3. Business Workflow for Failed Jobs

What happens when a job fails?  A confusion of written procedure manuals, e-mail and telephone escalation policies and criss-crossing of concerns and responsibilities.  No-one has a good solution for this.  Really what it amounts to is a notification and automated response (a la HQ), plus some issue tracking features (like in JIRA).