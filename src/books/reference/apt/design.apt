  ------
  Design

Design and Architecture

  Spring Batch Admin is a layered, extensible application.  Its main artifacts are 2 JAR files
  (libraries) containing all the content and business logic for the web application.  To deploy them
  you need a deployment platform, like a WAR file in a servlet container.  There is a sample application
  <<<spring-batch-admin-sample>>> which show how this works in practice. 

Application Context Structure

  There is a root or parent application context, and a child context for the UI components.  These
  are both loaded in the standard Spring MVC way following directives in web.xml.  There are also
  possibly several additional child contexts (of the main root) containing job configurations.
  
    * The root context is loaded from a file in the manager JAR, but all that does is import
    from well known locations on the classpath:
    
+---
<import resource="classpath*:/META-INF/spring/batch/bootstrap/**/*.xml"/>
<import resource="classpath*:/META-INF/spring/batch/override/**/*.xml"/>
+---

    * The UI child context is loaded in the same way from
    
+---
<import resource="classpath*:/META-INF/spring/batch/servlet/**/*.xml"/>
+---

    N.B. the child context by default only loads when you visit the first page in the 
    application.  You should be able to see which files it actually loads from the log
    statements that come out on the server console.
    
    * The job contexts are loaded by a special component (<<<ClasspathXmlJobLoader>>> from 
    Spring Batch) in the parent context.  It looks for individual files in the pattern
    <<<classpath*/META-INF/spring/batch/jobs/*.xml>>> and loads each file individually as its own self-contained
    context, registering any instance of Job it finds in the <<<JobRegistry>>> at the top level.
    
  The job contexts are loaded in this way so that you can provide your own jobs in multiple
  (possibly many) JAR files included in the application, but you do not have to worry too much about
  duplicate bean definitions because only the Job names have to be unique.  A job context inherits
  the AOP and <<<PropertyPlaceholderConfigurer>>> settings from the root context (not the standard behaviour
  of a child context) as a convenience, but you can add your own settings to apply locally as well.
  
Extending the UI

  There are two extension points for the UI: adding menus, and modifying the content of the existing
  pages.
  
* Adding a Menu

  Create a component of type <<<org.springframework.batch.admin.web.base.Menu>>> in the UI child 
  context (<<<META-INF/spring/batch/servlet/**/*.xml>>>).  It has a <<<url>>> property that should point to
  a controller mapping (relative to the application root context).  That's it really.
  
  If you want the page you add to show the other menus and links, you will want to 
  implement the view for the URL that you add in a specific way.  That is you will 
  use a Freemarker template to render the body of the page, and insert it in a Spring
  MVC <<<View>>> definition in your servlet XML configuration.  The template can use
  the standard layout in the application as a parent bean, and that way it inherits the 
  information architecture (menus and styling).  Look in the manager jar for
  <<<META-INF/spring/batch/servlet/manager/manager-context.xml>>> where you will find some examples. They 
  look like this:
  
+---
<bean name="jobs" parent="standard">
	<property name="attributes">
		<props merge="true">
			<prop key="body">/manager/jobs/jobs.ftl</prop>
			<prop key="titleCode">jobs.title</prop>
			<prop key="titleText">Spring Batch Admin: Jobs</prop>
		</props>
	</property>
</bean>
+---

  The only mandatory property in this is the "body", which is the location of a 
  Freemarker template for the main body (business content) of the page.  Freemarker
  templates by default have paths relative to either <<<classpath:/org/springframework/batch/admin/web>>>
  or <<</WEB-INF/web>>> (either works but the <<<WEB-INF>>> location is dynamically reloadable
  at development time).  The other
  properties shown above are to override the page title: the "code" is a key in
  the Spring <<<MessageSource>>> and the "text" is the default value if the code cannot 
  be resolved.